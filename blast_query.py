# Author: Emily Taylor, for the Data Science Team in the Goetsch Lab at Michigan Technological University
# Email: eetaylor@mtu.edu
# Purpose: This blast_query.py file contains all the functions pertaining to performing a blastx and tblastn search
# utilizing REST APIs, querying the ncbi server. The end product is a pandas dataframe containing all information
# pertinent to the search that was extracted from the results xml.

from yaspin import yaspin
import pandas as pd
from Bio import Entrez, SeqIO
from Bio.Blast import NCBIWWW, NCBIXML
from io import StringIO

# Set your email (required by NCBI)
Entrez.email = "eetaylor@mtu.edu"

# fetch_protein_sequence(accession) - This function fetches the protein sequence from NCBI by using the user-provided
# accession. Will throw an error if the accession isn't found in the NCBI database.
# INPUT accession - a string containing the NCBI accession number that corresponds to a protein. e.g. NP_000240.1
# RETURN record - a biopython data object that contains the exact protein code in fasta format and other information about the sequence.
# TODO: if error is thrown (e.g. accession not found in database), prompt user again for accession. Continue to prompt until success.
def fetch_protein_sequence(accession):
    handle = Entrez.efetch(db="protein", id=accession, rettype="fasta", retmode="text")
    record = SeqIO.read(handle, "fasta")
    handle.close()
    print("Protein sequence found in NCBI database")
    return record

# convert_seqrecord_to_fasta(seq_record) - converts the biopython seqrecord to a string in the format of a fasta file.
# INPUT seq_record - the seq record generated by the fetch_protein_sequence above
# RETURN fasta_io.getvalue() - the value of the fasta (e.g. string) that will be used in the ncbi api request
# TODO: verify type of the return object
def convert_seqrecord_to_fasta(seq_record):
    fasta_io = StringIO()
    SeqIO.write(seq_record, fasta_io, "fasta")
    return fasta_io.getvalue()

# run_blastp(sequence_record) - submits blastp query to NCBI via REST API (requests). Spinner will pop up in console
# while the submission is running and there are no results, and will change to a checkmark once the search is completed.
# INPUT sequence_record - object containing fasta record for the blastp search. To be used in API request
# RETURN result_handle - the url containing the results of the specific query
def run_blastp(sequence_record):
    with yaspin(text = "Running BLASTp search. This could take a while...") as spinner:
        result_handle = NCBIWWW.qblast(
            program="blastp",
            database="nr",  # or 'nr' if you prefer
            sequence=sequence_record.format("fasta"),
            hitlist_size=100  # adjust as needed
        )
        spinner.ok("✅ ")
    print("BLASTp search completed")
    return result_handle

# run_blastx(sequence_record) - submits blastx query to NCBI via REST API (requests). Spinner will pop up in console
# while the submission is running and there are no results, and will change to a checkmark once the search is completed.
# INPUT sequence_record - object containing fasta record for the blastp search. To be used in API request
# RETURN result_handle - the url containing the results of the specific query
def run_blastx(sequence_record):
    print("Finding equivalent nucleotide sequence for BLASTx query")
    trans_nucleotide = get_mrna_from_protein(sequence_record)
    with yaspin(text = "Running BLASTx query. This could take a while...") as spinner:
        result_handle = NCBIWWW.qblast(
            program="blastx",
            database = "nr",
            sequence = trans_nucleotide.format("fasta"),
            hitlist_size=100
        )
        spinner.ok("✅ ")
    print("BLASTx search completed")
    return result_handle

# get_mrna_from_protein(sequence_record) - function will extract accession from the record and find corresponding mrna sequence
# INPUT sequence_record - the biopython sequence record object, where protein id is extracted
# RETURN mrna_record - the biopython sequence record object that contains mrna information that corresponds to the
# protein sequence provided
def get_mrna_from_protein(sequence_record):
    # Extract accession from the record's ID
    protein_id = sequence_record.id
    if '|' in protein_id:
        protein_id = protein_id.split("|")[-2]  # Handles 'gi|123|ref|NP_000240.1|'

    # Step 1: Link protein to nucleotide CDS
    link_handle = Entrez.elink(
        dbfrom="protein",
        db="nucleotide",
        id=protein_id,
        linkname="protein_nuccore"   #may return genomic or mRNA sequences, not limited to CDS. Use with caution.
    )
    link_record = Entrez.read(link_handle)
    link_handle.close()

    # Step 2: Parse out the linked CDS ID
    try:
        linked_id = link_record[0]['LinkSetDb'][0]['Link'][0]['Id']
    except (IndexError, KeyError):
        print(f"No linked CDS/mRNA found for protein {protein_id}.")
        return None

    # Step 3: Fetch the CDS sequence
    fetch_handle = Entrez.efetch(
        db="nucleotide",
        id=linked_id,
        rettype="fasta",
        retmode="text"
    )
    mrna_record = SeqIO.read(fetch_handle, "fasta")
    fetch_handle.close()

    print("Equivalent nucleotide sequence search successful. Using " + mrna_record.format("fasta"))
    return mrna_record

# parse_blast_results(result_handle) - this function takes the xml file object returned from blastx and tblastn searches
# and extracts the information specified below in the function. Types of information can be changed based on pipeline needs
# INPUT result_handle - the url provided by run_blastx or run_tblastn that contains the results of the given query
# RETURN df - the pandas dataframe containing the parsed information from the query xml
def parse_blast_results(result_handle):
    blast_record = NCBIXML.read(result_handle)
    rows = []

    for alignment in blast_record.alignments:
        for hsp in alignment.hsps:
            rows.append({
                "query": blast_record.query,
                "hit_id": alignment.hit_id,
                "hit_def": alignment.hit_def,
                "accession": alignment.accession,
                "evalue": hsp.expect,
                "identity": hsp.identities,
                # "align_length": hsp.align_length,
                # "bit_score": hsp.bits,
                # "percent_identity": (hsp.identities / hsp.align_length) * 100 if hsp.align_length > 0 else 0,
                # "query_start": hsp.query_start,
                # "query_end": hsp.query_end,
                # "subject_start": hsp.sbjct_start,
                # "subject_end": hsp.sbjct_end,
            })

    df = pd.DataFrame(rows)
    print(blast_record.query + " dataframe created")
    return df